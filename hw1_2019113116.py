# -*- coding: utf-8 -*-
"""hw1_2019113116.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JlHh8Ac20kNGk8ArADFFw0VRr7LdjyHp
"""

#gpu 사용 가능 확인용
import torch
torch.cuda.is_available()

# 1. Cifar-10 이미지 데이터셋을 다운받고 분류하는 코드를 구현하세요.

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, Dataset
from torchsummary import summary
import torch.nn.functional as F

# 데이터 전처리 및 데이터 로드
transform = transforms.Compose([
    transforms.ToTensor()
])

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# CIFAR-10 데이터셋 로드
cifar_train = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)

# 데이터셋으로 DataLoader 생성
batch_size = 64

train_loader = DataLoader(cifar_train, batch_size=batch_size, shuffle=True)

''' Image 확인용
import matplotlib.pyplot as plt
import numpy as np
classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')
def imshow(img):
    img = img / 2 + 0.5     # unnormalize
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()
dataiter = iter(train_loader)
images, labels = next(dataiter)

# show images
imshow(torchvision.utils.make_grid(images))
'''

#신경망 정의
class SimpleCNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(3, 32, 3)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(32, 64, 3)
        self.conv3 = nn.Conv2d(64, 128, 3)
        self.drop1 = nn.Dropout()
        self.fc2 = nn.Linear(512 * 2 * 2, 128)
        self.fc3 = nn.Linear(128, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool(x)

        x = F.relu(self.conv2(x))
        x = self.pool(x)

        x = F.relu(self.conv3(x))

        x = torch.flatten(x, 1)
        x = F.relu(self.fc2(x))
        x = self.drop1(x)
        x = self.fc3(x)
        return x

# 모델, 손실 함수, 최적화 함수 정의
model = SimpleCNN().to(device)
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
summary(model, input_size=(3, 32, 32)) # Summary 출력

# 훈련
epochs = 50
for epoch in range(epochs):
    correct = 0
    total = 0
    for imgs, labels in train_loader:
        optimizer.zero_grad()
        imgs = imgs.to(device)
        outputs = model(imgs)
        _, prediction = torch.max(outputs.data, 1)
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))] # 0 0 0 1 0 0 0 0 0 0 형태로 만들어주기 위한 배열
        for t in range(len(labels)):
          new_labels[t][labels[t]] = 1.0
        new_labels = torch.tensor(new_labels)
        labels = labels.to(device)
        new_labels = new_labels.to(device)
        prediction = prediction.to(device)
        loss = criterion(outputs, new_labels) #loss 계산(BCEWithLogitsLoss)
        loss.backward()
        optimizer.step()
        total += (prediction == prediction).sum().item()
        correct += (prediction == labels).sum().item()

    print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}, Accuracy: {correct / total * 100:.2f}%') # Loss, Accuracy 출력

print('훈련 완료')

# 테스트
model.eval().to(device)
correct = 0
total = 0

with torch.no_grad():
    for imgs, labels in train_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        _, prediction = torch.max(outputs.data, 1)
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          new_labels[t][labels[t]] = 1.0
        new_labels = torch.tensor(new_labels)
        new_labels = new_labels.to(device)
        labels = labels.to(device)
        prediction = prediction.to(device)
        loss = criterion(outputs, new_labels)
        total += (prediction == prediction).sum().item()
        correct += (prediction == labels).sum().item()
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Loss, Accuracy

accuracy = correct / total
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Accuracy

testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)
batch_size = 64
test_loader = DataLoader(testset, batch_size=batch_size, shuffle=True)

correct = 0
total = 0

with torch.no_grad():
    for imgs, labels in test_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        _, prediction = torch.max(outputs.data, 1)
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          new_labels[t][labels[t]] = 1.0
        new_labels = torch.tensor(new_labels)
        new_labels = new_labels.to(device)
        labels = labels.to(device)
        prediction = prediction.to(device)
        loss = criterion(outputs, new_labels)
        total += (prediction == prediction).sum().item()
        correct += (prediction == labels).sum().item()
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Loss, Accuracy

accuracy = correct / total
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Accuracy

#2. Cifar-10 이미지를 아래의 이미지처럼 4개씩 묶고 분류할 수 있는 모델을 구현하세요.

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, Dataset
from torchsummary import summary
import torch.nn.functional as F

normalize = transforms.Normalize(mean=[0.485, 0.456, 0.406],
                                 std=[0.229, 0.224, 0.225])

# 데이터 전처리 및 데이터 로드
transform = transforms.Compose([
    transforms.ToTensor(),
    normalize
])

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# CIFAR-10 데이터셋 로드
cifar_train = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)

class CIFAR10Dataset(Dataset):
    def __init__(self, original_dataset):
        self.original_dataset = original_dataset

    def __len__(self):
        return len(self.original_dataset) // 4  # 4개씩 묶어서 사용

    def __getitem__(self, idx):
        img1, label1 = self.original_dataset[idx * 4]
        img2, label2 = self.original_dataset[idx * 4 + 1]
        img3, label3 = self.original_dataset[idx * 4 + 2]
        img4, label4 = self.original_dataset[idx * 4 + 3]

        concatenated_img1 = torch.cat([img1, img2], dim=2)
        concatenated_img2 = torch.cat([img3, img4], dim=2)
        concatenated_img = torch.cat([concatenated_img1, concatenated_img2], dim=1)
        concatenated_lbl = torch.tensor([label1, label2, label3, label4])

        return concatenated_img, concatenated_lbl

# 이어붙인 데이터셋으로 DataLoader 생성
batch_size = 64

concatenated_train_data = CIFAR10Dataset(cifar_train)
train_loader = DataLoader(concatenated_train_data, batch_size=batch_size, shuffle=True)

''' Image 확인용
import matplotlib.pyplot as plt
import numpy as np
classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')
def imshow(img):
    img = img / 2 + 0.5     # unnormalize
    npimg = img.numpy()
    plt.imshow(np.transpose(npimg, (1, 2, 0)))
    plt.show()
dataiter = iter(train_loader)
images, labels = next(dataiter)

# show images
imshow(torchvision.utils.make_grid(images))
'''

#신경망 정의
class SimpleCNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(3, 32, 3)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(32, 64, 3)
        self.conv3 = nn.Conv2d(64, 128, 3)
        self.conv4 = nn.Conv2d(128, 256, 3)
        self.drop1 = nn.Dropout()
        self.fc1 = nn.Linear(256 * 2 * 2, 512)
        self.fc2 = nn.Linear(512, 128)
        self.fc3 = nn.Linear(128, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool(x)

        x = F.relu(self.conv2(x))
        x = self.pool(x)

        x = F.relu(self.conv3(x))
        x = self.pool(x)

        x = F.relu(self.conv4(x))
        x = self.pool(x)

        x = torch.flatten(x, 1)
        x = F.relu(self.fc1(x))
        x = self.drop1(x)
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x

# 모델, 손실 함수, 최적화 함수 정의
model = SimpleCNN().to(device)
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
summary(model, input_size=(3, 64, 64)) # Summary 출력

# 훈련
epochs = 50
for epoch in range(epochs):
    correct = 0
    total = 0
    for imgs, labels in train_loader:
        optimizer.zero_grad()
        imgs = imgs.to(device)
        outputs = model(imgs)
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))] # 1 0 0 1 0 0 1 1 0 0 형태로 만들어주기 위한 배열
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels) #loss 계산(BCEWithLogitsLoss)
        loss.backward()
        optimizer.step()
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        total += (labels == labels).sum().item()
        correct += (pred_binary == labels).sum().item()

    print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}, Accuracy: {correct / total * 100:.2f}%') # Loss, Accuracy 출력

print('훈련 완료')

# 테스트
model.eval().to(device)
correct = 0
total = 0
correct2 = 0
total2 = 0

with torch.no_grad():
    for imgs, labels in train_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels)
        total2 += (labels == labels).sum().item()
        correct2 += (pred_binary == labels).sum().item()
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            if (labels[t][j] == 1.0):
              total += 1
              if (pred_binary[t][j] == 1.0):
                correct += 1
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
        print(f'Loss: {loss.item():.4f} Accuracy2: {(correct2 / total2 * 100):.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

accuracy = correct / total
accuracy2 = correct2 / total2
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
print(f'Final Test Accuracy2: {accuracy2 * 100:.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

testset = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)

concatenated_test_data = CIFAR10Dataset(testset)
# 이어붙인 데이터셋으로 DataLoader 생성
batch_size = 64
test_loader = DataLoader(concatenated_test_data, batch_size=batch_size, shuffle=True)

correct = 0
total = 0
correct2 = 0
total2 = 0

with torch.no_grad():
    for imgs, labels in test_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels)
        total2 += (labels == labels).sum().item()
        correct2 += (pred_binary == labels).sum().item()
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            if (labels[t][j] == 1.0):
              total += 1
              if (pred_binary[t][j] == 1.0):
                correct += 1
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
        print(f'Loss: {loss.item():.4f} Accuracy2: {(correct2 / total2 * 100):.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

accuracy = correct / total
accuracy2 = correct2 / total2
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
print(f'Final Test Accuracy2: {accuracy2 * 100:.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

# 2-2. MNIST 데이터를 4장씩 아래의 형태로 묶어서 분류할 수 있는 모델을 만들고 학습 및 테스트를 할 수 있는 코드를 제출하세요.

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
from torch.utils.data import DataLoader, Dataset
from torchsummary import summary
import torch.nn.functional as F

normalize = transforms.Normalize(mean=[0.485],
                                 std=[0.229])

# 데이터 전처리 및 데이터 로드
transform = transforms.Compose([
    transforms.ToTensor(),
    normalize
])

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# CIFAR-10 데이터셋 로드
cifar_train = torchvision.datasets.MNIST(root='./data', train=True, download=True, transform=transform)

class CIFAR10Dataset(Dataset):
    def __init__(self, original_dataset):
        self.original_dataset = original_dataset

    def __len__(self):
        return len(self.original_dataset) // 4  # 4개씩 묶어서 사용

    def __getitem__(self, idx):
        img1, label1 = self.original_dataset[idx * 4]
        img2, label2 = self.original_dataset[idx * 4 + 1]
        img3, label3 = self.original_dataset[idx * 4 + 2]
        img4, label4 = self.original_dataset[idx * 4 + 3]

        concatenated_img1 = torch.cat([img1, img2], dim=2)
        concatenated_img2 = torch.cat([img3, img4], dim=2)
        concatenated_img = torch.cat([concatenated_img1, concatenated_img2], dim=1)
        concatenated_lbl = torch.tensor([label1, label2, label3, label4])

        return concatenated_img, concatenated_lbl

concatenated_train_data = CIFAR10Dataset(cifar_train)
# 이어붙인 데이터셋으로 DataLoader 생성
batch_size = 64

train_loader = DataLoader(concatenated_train_data, batch_size=batch_size, shuffle=True)

class SimpleCNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 32, 3)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(32, 64, 3)
        self.conv3 = nn.Conv2d(64, 128, 3)
        self.conv4 = nn.Conv2d(128, 256, 3)
        self.drop1 = nn.Dropout()
        self.fc1 = nn.Linear(256, 128)
        self.fc3 = nn.Linear(128, 10)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool(x)

        x = F.relu(self.conv2(x))
        x = self.pool(x)

        x = F.relu(self.conv3(x))
        x = self.pool(x)

        x = F.relu(self.conv4(x))
        x = self.pool(x)

        x = torch.flatten(x, 1)
        x = F.relu(self.fc1(x))
        x = self.drop1(x)
        x = self.fc3(x)
        return x

# 모델, 손실 함수, 최적화 함수 정의
model = SimpleCNN().to(device)
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
summary(model, input_size=(1, 56, 56))

# 훈련
epochs = 50
for epoch in range(epochs):
    for imgs, labels in train_loader:
        optimizer.zero_grad()
        imgs = imgs.to(device)
        outputs = model(imgs)
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))] # 1 0 0 1 0 0 1 1 0 0 형태로 만들어주기 위한 배열
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels) #loss 계산(BCEWithLogitsLoss)
        loss.backward()
        optimizer.step()
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        total += (labels == labels).sum().item()
        correct += (pred_binary == labels).sum().item()

    print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}, Accuracy: {correct / total * 100:.2f}%') # Loss, Accuracy 출력

print('훈련 완료')

# 테스트
model.eval().to(device)
correct = 0
total = 0
correct2 = 0
total2 = 0

with torch.no_grad():
    for imgs, labels in train_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels)
        total2 += (labels == labels).sum().item()
        correct2 += (pred_binary == labels).sum().item()
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            if (labels[t][j] == 1.0):
              total += 1
              if (pred_binary[t][j] == 1.0):
                correct += 1
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
        print(f'Loss: {loss.item():.4f} Accuracy2: {(correct2 / total2 * 100):.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

accuracy = correct / total
accuracy2 = correct2 / total2
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
print(f'Final Test Accuracy2: {accuracy2 * 100:.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

testset = torchvision.datasets.MNIST(root='./data', train=False, download=True, transform=transform)

concatenated_test_data = CIFAR10Dataset(testset)
# 이어붙인 데이터셋으로 DataLoader 생성
batch_size = 64
test_loader = DataLoader(concatenated_test_data, batch_size=batch_size, shuffle=True)

correct = 0
total = 0
correct2 = 0
total2 = 0

with torch.no_grad():
    for imgs, labels in test_loader:
        imgs = imgs.to(device)
        outputs = model(imgs)
        pred_soft = torch.sigmoid(outputs)
        pred_binary = pred_soft.gt(0.5).type(outputs.type())
        new_labels = [[0.0 for tt in range(10)] for t in range(len(labels))]
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            new_labels[t][labels[t][j]] = 1.0
        labels = torch.tensor(new_labels)
        labels = labels.to(device)
        loss = criterion(outputs, labels)
        total2 += (labels == labels).sum().item()
        correct2 += (pred_binary == labels).sum().item()
        for t in range(len(labels)):
          for j in range(len(labels[t])):
            if (labels[t][j] == 1.0):
              total += 1
              if (pred_binary[t][j] == 1.0):
                correct += 1
        print(f'Loss: {loss.item():.4f} Accuracy: {(correct / total * 100):.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
        print(f'Loss: {loss.item():.4f} Accuracy2: {(correct2 / total2 * 100):.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)

accuracy = correct / total
accuracy2 = correct2 / total2
print(f'Final Test Accuracy: {accuracy * 100:.2f}%') # Label이 1일 때, 추정값도 1인 개수 비율
print(f'Final Test Accuracy2: {accuracy2 * 100:.2f}%') # 추정값 중 얼마나 맞았는지에 대한 비율 (Label과 추정값이 얼마나 같은지에 대한 비율)